---
title: "Crypto-devises"
author: "Habiba BOUAJLA, Kevin AUBRIET & Gabriel CURINGA"
date: "07/01/2019"
output: html_document
---

<style>
body {
text-align: justify
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r import, message=FALSE, warning=FALSE, include=FALSE}
##import librairies
library(readr)
library(stringr)
library(lubridate)
library(ggplot2)
library(reshape2)
library(tidyr)
library(scales)
library(corrplot)
```

# Table des matières
- [Présentation du groupe et du rôle de chacun](#groupe)
- [Descriptif sujet et ses finalités](#descriptif)
- [Données utilisées](#donnees)
- [Méthodologie suivie pour répondre aux questions](#methodologie)
- [Résultats obtenus et visualisation graphique](#resultats)

# Présentation du groupe et du rôle de chacun <a name="groupe"></a>

# Descriptif sujet et ses finalités <a name="descriptif"></a>

# Méthodologie suivie pour répondre aux questions <a name="methodologie"></a>

# Données utilisées <a name="donnees"></a>

Premièrement, nous avons recherché des données sur l'évolution du cours du Bitcoin depuis ces dernières années. En suite, il était important de faire coïncider ces données avec l'évolution du cours des autres crypto-monnaies majeures : Etherum, Litecoin, Dash, Monero, Ripple, Nem. Finalement, nous sommes parvenus à trouver des fichiers au format CSV (facilement exploitable) qui contiennent la quasi totalité des données que nous recherchions de 2013 à 2018 pour chaque monnaie.

### Sources des données

La récolte de données s'est faite sur des sites plutôt réputés, ou du moins dont on est sûrs de la véracité de celles-ci.

* [data.gouv.fr](https://www.data.gouv.fr)
* [kaggle.com](https://www.kaggle.com/dbarkhorn/crypto-correlation/data)

### Données récoltées

* En dollars
    + Prix du premier achat du jour (Open)
    + Prix du dernier achat du jour (Close)
    + Prix le plus bas du jour (Low)
    + Prix le plus haut du jour (High)
* La valeur de toutes les unités de la crypto-monnaie échangées dans la journée (Volume)
* La valeur de toutes les unités de la crypto-monnaie sur le marché (Market.Cap)
* Variations d'un jour à l'autre du cours du Bitcoin en %

Nous avons effectué des fonctions de récupération de chaque élément d'une date (jour, mois et année) dans le but de nous faciliter la tâche dans l'exploitation des données et surtout dans la création de graphique.
```{r sort_date, echo=TRUE, message=FALSE, warning=FALSE}
##Extraction de l'année
getYear <- function(str) {
  res <- str_split(str, ", ")[[1]][[length(str_split(str, ", ")[[1]])]]
  return(res)
}
##Extraction du mois
getMonth <- function(str){
  res <- str_split(str, ", ")[[1]][1]
  res <- str_split(res, " ")[[1]][1]
  return(res)
}
##Extraction du jour
getDay <- function(str){
  res <- str_split(str, ", ")[[1]][1]
  res <- str_split(res, " ")[[1]][2]
  return(res)
}
```

Souvent, nous avons dû traiter les données déjà présentes dans les fichiers CSV pour les formater de manières à ce qu'elles soient exploitables. Par exemple, ci-dessous nous avons dû créer une fonction qui retire le symbole "%".
```{r sort_get_variation, echo=TRUE, message=FALSE, warning=FALSE}
getVariation <- function(str){
  res <- str_replace(str, "%", "")
  return(res)
}
```

Get data
```{r sort_, echo=TRUE, message=FALSE, warning=FALSE}
getData2015 <-function(src){
  res <- read.csv(src)
  ##Ajout des colonnes jour, mois et année
  ##pour faciliter le traitement des données
  for (i in 1:nrow(res)) {
    res$Day[i] <- as.numeric(getDay(res$Date[i]))
    res$Month[i] <- match(getMonth(res$Date[i]), month.abb)
    res$Year[i] <- as.numeric(getYear(res$Date[i]))
    
    ##Creation d'une nouvelle colonne Date
    ##Du type date plus exploitable
    date <- paste(res$Year[i], res$Month[i], sep = "-", collapse=NULL)
    date <- paste(date, res$Day[i], sep = "-", collapse=NULL)
    res$DateFormat[i] <- format(as.Date(date))
    
  }
  ##on ne conserve que les données datant au minimum de 2015
  resF<-res[res$Year>=2015,]
  
  ##tri dans l'ordre des années puis des mois
  resF <- resF[order(month(resF$Day)),]
  resF <- resF[order(month(resF$Month)),]
  resF <- resF[order(month(resF$Year)),]
  
  return(resF)
}
```

```{r sort_recup_datas, message=FALSE, warning=FALSE, include=FALSE}
variationBtc <- read_csv("../data/bitcoin_variation.csv")
bitcoin_price_sorted<-getData2015("../data/all/bitcoin_price.csv")

##Creation d'une nouvelle colonne Date
##Du type date plus exploitable
for(j in 1:nrow(variationBtc)){
  variationBtc$Year[j] <- as.numeric(year(variationBtc$Date[j]))
  variationBtc$Month[j] <- as.numeric(month(variationBtc$Date[j]))
  variationBtc$Variation[j] <- as.numeric(getVariation(variationBtc$`Variation 24h`[j]))
}

##on ne conserve que les données datant au minimum de 2015
variationBtc_sorted <- variationBtc[variationBtc$Year >= 2016,]
variationBtc_sorted<- variationBtc_sorted[,-2]
variationBtc_sorted<- variationBtc_sorted[,-2]
```

# Résultats obtenus et visualisation graphique <a name="resultats"></a>

### Évolution du cours du bitcoin de 2015 à 2017

```{r evolution_cours_btc_formatDatas, message=FALSE, warning=FALSE, include=FALSE}
bitcoin_price_sorted$Year <- as.factor(bitcoin_price_sorted$Year)

bitcoin_price_sorted2016 <-bitcoin_price_sorted[bitcoin_price_sorted$Year == 2016,]
bitcoin_price_sorted2016 <- bitcoin_price_sorted2016[-60,] # On supprime la 60eme ligne (qui equivaut au 29 février)

bitcoin_price_sorted2015 <-bitcoin_price_sorted[bitcoin_price_sorted$Year == 2015,]
bitcoin_price_sorted2017 <-bitcoin_price_sorted[bitcoin_price_sorted$Year == 2017,]

resultats <- data.frame(Val2015= bitcoin_price_sorted2015$Close, Val2016=bitcoin_price_sorted2016$Close, Val2017=bitcoin_price_sorted2017$Close, Moi=bitcoin_price_sorted2015$Month ,Jour=bitcoin_price_sorted2015$DateFormat)
```

```{r plot_evolution_cours_btc, echo=TRUE, message=FALSE, warning=FALSE}

prediction2 <- gather(
  data = resultats,
  key = TYPE,
  value = VAL,
  Val2015,Val2016, Val2017
)

ggplot(
  prediction2,
  aes(x = as.Date(Jour), y = VAL, color = TYPE),)+
  ggtitle("Évolution du cours du Bitcoin de 2015 à 2017")+
  ylab("Values")+
  scale_x_date(name="Months", labels = date_format("%b"), breaks = "1 month")+
  geom_line()
```


### Variations du cours du Bitcoin en 2016 et 2017
```{r variations_btc, message=FALSE, warning=FALSE, include=FALSE}
variationBtc_sorted_2016 <- variationBtc_sorted[variationBtc_sorted$Year == 2016,]
variationBtc_sorted_2016 <- variationBtc_sorted_2016[-60,]

variationBtc_sorted_2017 <- variationBtc_sorted[variationBtc_sorted$Year == 2017,]
```


```{r plot_variations_btc, echo=TRUE, message=FALSE, warning=FALSE}
## Création d'un nouveau data frame
## Plus exploitable
df <- data.frame(Val2016 = variationBtc_sorted_2016$Variation, 
                 Val2017 = variationBtc_sorted_2017$Variation, 
                 Month=variationBtc_sorted_2016$Month,
                 Date=variationBtc_sorted_2016$Date)

datas <- gather(
  data = df,
  key = TYPE,
  value = VAL,
  Val2016, Val2017
)

## Variations du cours du bitcoin en 2016 & 2017
## En %

ggplot(
  datas,
  aes(x = as.Date(Date), y = VAL, color = TYPE),)+
  ggtitle("Variations du cours du Bitcoin en 2016 & 2017")+
  ylab("Valeurs")+
  scale_x_date(name="Months", labels = date_format("%b"), breaks = "1 month")+
  geom_line()
```


### Tests de corrélations

```{r read_datas_corr, message=FALSE, warning=FALSE, include=FALSE}
#graphs de corrélation des open (bitcoin par rapport aux autres crypto)
graphsO <- read.csv("../data/all/final_csv_open.csv")

#graphs de corrélation des close (bitcoin par rapport aux autres crypto)
graphsC <- read.csv("../data/all/final_csv_close.csv")

#graphs de corrélation des market cap (bitcoin par rapport aux autres crypto)
graphsM <- read.csv("../data/all/final_csv_market_cap.csv")
```


```{r calcul_matrice_corr, echo=TRUE, message=FALSE, warning=FALSE}

#calcule de la matrice de corrélation
correlationTable <- function(graphs) {
  #matrice de corrélation
  cross <- matrix(nrow = length(graphs), ncol = length(graphs))
  for(graph1Id in 1:length(graphs)){
    graph1 <- graphs[[graph1Id]]
    print(graph1Id)
    for(graph2Id in 1:length(graphs)) {
      graph2 <- graphs[[graph2Id]]
      if(graph1Id == graph2Id){
        break;
      } else {
        correlation <- ccf(graph1, graph2, lag.max = 0)
        cross[graph1Id, graph2Id] <- correlation$acf[1]
      }
    }
  }
  cross
}
```

```{r format_corr, message=FALSE, warning=FALSE, include=FALSE}
#graphs de corrélation des open (bitcoin par rapport aux autres crypto)
corrO <- correlationTable(graphsO)
#renommage des colnames et rownames
colnames(corrO) <- c("bitcoin_cash", "bitcoin", "bitconnect", "dash", "ethereum_classic", "ethereum", "iota",
                    "litecoin", "nem", "monero", "numeraire", "omisego", "neo", "ripple", "stratis", "qtum", "waves")
rownames(corrO) <- c("bitcoin_cash", "bitcoin", "bitconnect", "dash", "ethereum_classic", "ethereum", "iota",
                    "litecoin", "nem", "monero", "numeraire", "omisego", "neo", "ripple", "stratis", "qtum", "waves")

#graphs de corrélation des close (bitcoin par rapport aux autres crypto)
corrC <- correlationTable(graphsC)
colnames(corrC) <- c("bitcoin_cash", "bitcoin", "bitconnect", "dash", "ethereum_classic", "ethereum", "iota",
                    "litecoin", "nem", "monero", "numeraire", "omisego", "neo", "ripple", "stratis", "qtum", "waves")
rownames(corrC) <- c("bitcoin_cash", "bitcoin", "bitconnect", "dash", "ethereum_classic", "ethereum", "iota",
                    "litecoin", "nem", "monero", "numeraire", "omisego", "neo", "ripple", "stratis", "qtum", "waves")

#graphs de corrélation des market cap (bitcoin par rapport aux autres crypto)
corrM <- correlationTable(graphsM)
colnames(corrM) <- c("bitcoin_cash", "bitcoin", "bitconnect", "dash", "ethereum_classic", "ethereum", "iota",
                    "litecoin", "nem", "monero", "numeraire", "omisego", "neo", "ripple", "stratis", "qtum", "waves")
rownames(corrM) <- c("bitcoin_cash", "bitcoin", "bitconnect", "dash", "ethereum_classic", "ethereum", "iota",
                    "litecoin", "nem", "monero", "numeraire", "omisego", "neo", "ripple", "stratis", "qtum", "waves")
```


```{r plot_corr, echo=TRUE, message=FALSE, warning=FALSE}
#Corrélogramme : visualisation de la matrice de corrélation des open
corrplot(corrO, method="ellipse",type="lower")

#Corrélogramme : visualisation de la matrice de corrélation des open
corrplot(corrC, method="pie",type="lower")

#Corrélogramme : visualisation de la matrice de corrélation des open
corrplot(corrM, type="lower")
```


