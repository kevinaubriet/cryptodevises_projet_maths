---
title: "Crypto-devises"
author: "Habiba BOUAJLA, Kevin AUBRIET & Gabriel CURINGA"
date: "07/01/2019"
output: 
  html_document:
    reference_html: Crypto-devises.html
    toc: true
  
---

<style>
body {
text-align: justify
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r import, message=FALSE, warning=FALSE, include=FALSE}
##import librairies
library(readr)
library(stringr)
library(lubridate)
library(ggplot2)
library(reshape2)
library(tidyr)
library(scales)
library(corrplot)
library(forcats)
```

# Présentation du groupe et du rôle de chacun <a name="groupe"></a>
Notre groupe est composé de 3 membres : Habiba Bouajla, Gabriel Curinga et Kevin Aubriet. Dans un premier temps, nous nous sommes pas répartis les tahes mais avons préférer travailler tous ensemble sur la sélection des données ainsi que le traitment des dataframes pour pourvoir se familiariser avec le language R et s'entraider. Une fois tout le monde à l'aise avec la gestion des données avec R, nous nous sommes répartis les taches comme ceci : Habiba s'est occupée du test de correlation du bitcoin avec les autres crypto-monnaies qui comprent un script de test de correlation ainsi que 3 matrices. Gabriel lui a généré des graphiques du cours du bitcoin (un avec une seule courbe et un autre avec plusieurs courbes pour chaque année), un graphique de variation du bicoin pour voir les différentes hausses ou baisses du bitcoin. Kevin avait comme tahce de réaliser les scripts de calcul du court de bitcoin comprenant le calcul des moyennes,variances et écart type de différentes données, de faire deux graphiques un camembert pour analyser le marketCap du bitcoin par rapport aux autres crypto-monnnaies et un graphique avec plusieurs courbes pour chaque crypto-monnaie.
Le rapport et le support de présentation orale a été fait par tous les membres de l'équipe.
# Descriptif sujet et ses finalités

Depuis plusieurs années, le phénomène de la crypto-monnaie prend de plus en plus de place dans nos mondes bancaires et financiers. Il s’agit d’une monnaie virtuelle et cryptée, c’est-à-dire qu’elle n’est utilisable que par une personne possédant le code permettant de décrypter la monnaie.
Comparées aux monnaies ordinaires, les cryptomonnaies sont gérées par un grand livre de comptes ouvert et consultable par tous (la blockchain) qui répertorie l'ensemble des transactions depuis l'origine. Ainsi, nous voudrons faire quelques considérations en exploitant les données qui nous sont mises à disposition par la blockchain.

L’objectif de notre projet est d’utiliser les données des cours des crypto-devises de 2015, 2016 et 2017. Cela a pour but de calculer la moyenne et la variance d’un certain nombre de variables comme le cours du Bitcoin, la valeur des transactions et la part de marché par crypto-monnaies. Nous avons également effectué un test de corrélation pour vérifier si les autres crypto-devises sont ou pas corrélées au Bitcoin.

# Présentation du groupe et du rôle de chacun

# Méthodologie suivie pour répondre aux questions

Pour mener à bien notre projet et répondre le plus précisement possible aux objectifs, nous avons tout d'abord rechercher les données relatives aux crypto-monnaies les mieux adaptées. La qualité des données récoltées est primordiale dans un tel exercice où nous souhaitons effectuer des vérifications d'hypothèses et des tests de corrélations.
C'est alors que le groupe a démarré un projet dans le langage R dans lequel nous avons mis en place un environnement de travail qui suit l'architecture suivante : 

* PRE = scripts d'imports et de traitements des données
* FIG = scripts de créations des graphiques
* R = scripts de vérifications d'hypothèses et des tests de corrélations
* REP = dossier contenant le rapport
* data = dossier contenant les données exploitées dans ce projet

Tout ce projet se trouve sur un [git]("https://github.com/kevinaubriet/cryptodevises_projet_maths.git") (hebergé sur GitHub) pour faciliter le travail en groupe évidemment.

Une fois que l'environnement a été mis en place, nous avons effectué tous les traitements de données/tableaux pour en tirer uniquement les choses utiles.



# Données utilisées

Premièrement, nous avons recherché des données sur l'évolution du cours du Bitcoin depuis ces dernières années. En suite, il était important de faire coïncider ces données avec l'évolution du cours des autres crypto-monnaies majeures : Etherum, Litecoin, Dash, Monero, Ripple, Nem. Finalement, nous sommes parvenus à trouver des fichiers au format CSV (facilement exploitable) qui contiennent la quasi totalité des données que nous recherchions de 2013 à 2018 pour chaque monnaie.

### Sources des données

La récolte de données s'est faite sur des sites plutôt réputés, ou du moins dont on est sûrs de la véracité de celles-ci.

* [data.gouv.fr](https://www.data.gouv.fr)
* [kaggle.com](https://www.kaggle.com/dbarkhorn/crypto-correlation/data)

### Données récoltées

* En dollars
    + Prix du premier achat du jour (Open)
    + Prix du dernier achat du jour (Close)
    + Prix le plus bas du jour (Low)
    + Prix le plus haut du jour (High)
* La valeur de toutes les unités de la crypto-monnaie échangées dans la journée (Volume)
* La valeur de toutes les unités de la crypto-monnaie sur le marché (Market.Cap)
* Variations d'un jour à l'autre du cours du Bitcoin en %

### Traitement des données

Les données que nous avons récupéré ne correspondaient pas parfaitement à un traitement convenable. C'est pourquoi nous avons décidé de les formater.

Nous avons effectué des fonctions de récupération de chaque élément d'une date (jour, mois et année) dans le but de nous faciliter la tâche dans l'exploitation des données et surtout dans la création de graphique.
```{r sort_date, echo=TRUE, message=FALSE, warning=FALSE}
##Extraction de l'année
getYear <- function(str) {
  res <- str_split(str, ", ")[[1]][[length(str_split(str, ", ")[[1]])]]
  return(res)
}
##Extraction du mois
getMonth <- function(str){
  res <- str_split(str, ", ")[[1]][1]
  res <- str_split(res, " ")[[1]][1]
  return(res)
}
##Extraction du jour
getDay <- function(str){
  res <- str_split(str, ", ")[[1]][1]
  res <- str_split(res, " ")[[1]][2]
  return(res)
}
```


Souvent, nous avons dû traiter les données déjà présentes dans les fichiers CSV pour les formater de manières à ce qu'elles soient exploitables. Par exemple, ci-dessous nous avons dû créer une fonction qui retire le symbole "%".
```{r sort_get_variation, echo=TRUE, message=FALSE, warning=FALSE}
getVariation <- function(str){
  res <- str_replace(str, "%", "")
  return(res)
}
```

La fonction getData prend en parametre la source d'un fichier csv.En effet, nous avons récupérer un groupe de fichier csv (comprenant chacun les données d'une crypto-monnaie) qui disposait de la même structure, nous avons donc fait une fonction pour pouvoir les traiter. La fonction va lire le csv, ensuite rajouter 3 colonnes pour faciliter le traitement de la date (la date du tableaux de données étaient inexploitables). Grace à tout cela, nous avons trier notre tableau pour garder que les données concernant les années passées 2015.
```{r sort_, echo=TRUE, message=FALSE, warning=FALSE}

getData2015 <-function(src){
  res <- read.csv(src)
  ##Ajout des colonnes jour, mois et année
  ##pour faciliter le traitement des données
  for (i in 1:nrow(res)) {
    res$Day[i] <- as.numeric(getDay(res$Date[i]))
    res$Month[i] <- match(getMonth(res$Date[i]), month.abb)
    res$Year[i] <- as.numeric(getYear(res$Date[i]))
    
    ##Creation d'une nouvelle colonne Date
    ##Du type date plus exploitable
    date <- paste(res$Year[i], res$Month[i], sep = "-", collapse=NULL)
    date <- paste(date, res$Day[i], sep = "-", collapse=NULL)
    res$DateFormat[i] <- format(as.Date(date))
    
  }
  ##on ne conserve que les données datant au minimum de 2015
  resF<-res[res$Year>=2015,]
  
  ##tri dans l'ordre des années puis des mois
  resF <- resF[order(month(resF$Day)),]
  resF <- resF[order(month(resF$Month)),]
  resF <- resF[order(month(resF$Year)),]
  
  return(resF)
}
```

```{r import_datas, message=FALSE, warning=FALSE, include=FALSE}
#récupération des données
bitcoin_price_sorted<-getData2015("../data/all/bitcoin_price.csv")
dash_price_sorted<-getData2015("../data/all/dash_price.csv")
ethereum_price_sorted<-getData2015("../data/all/ethereum_price.csv")
litecoin_price_sorted<-getData2015("../data/all/litecoin_price.csv")
monero_price_sorted<-getData2015("../data/all/monero_price.csv")
nem_price_sorted<-getData2015("../data/all/nem_price.csv")
ripple_price_sorted<-getData2015("../data/all/ripple_price.csv")

#graphs de corrélation des open (bitcoin par rapport aux autres crypto)
graphsO <- read.csv("../data/all/final_csv_open.csv")

#graphs de corrélation des close (bitcoin par rapport aux autres crypto)
graphsC <- read.csv("../data/all/final_csv_close.csv")

#graphs de corrélation des market cap (bitcoin par rapport aux autres crypto)
graphsM <- read.csv("../data/all/final_csv_market_cap.csv")
```

```{r sort_recup_datas, message=FALSE, warning=FALSE, include=FALSE}
variationBtc <- read_csv("../data/bitcoin_variation.csv")
bitcoin_price_sorted<-getData2015("../data/all/bitcoin_price.csv")

##Creation d'une nouvelle colonne Date
##Du type date plus exploitable
for(j in 1:nrow(variationBtc)){
  variationBtc$Year[j] <- as.numeric(year(variationBtc$Date[j]))
  variationBtc$Month[j] <- as.numeric(month(variationBtc$Date[j]))
  variationBtc$Variation[j] <- as.numeric(getVariation(variationBtc$`Variation 24h`[j]))
}

##on ne conserve que les données datant au minimum de 2015
variationBtc_sorted <- variationBtc[variationBtc$Year >= 2016,]
variationBtc_sorted<- variationBtc_sorted[,-2]
variationBtc_sorted<- variationBtc_sorted[,-2]
```

# Résultats obtenus et visualisation graphique <a name="resultats"></a>

### Évolution du cours du bitcoin de 2015 à 2017

```{r evolution_cours_btc_formatDatas, message=FALSE, warning=FALSE, include=FALSE}
bitcoin_price_sorted$Year <- as.factor(bitcoin_price_sorted$Year)

bitcoin_price_sorted2016 <-bitcoin_price_sorted[bitcoin_price_sorted$Year == 2016,]
bitcoin_price_sorted2016 <- bitcoin_price_sorted2016[-60,] # On supprime la 60eme ligne (qui equivaut au 29 février)

bitcoin_price_sorted2015 <-bitcoin_price_sorted[bitcoin_price_sorted$Year == 2015,]
bitcoin_price_sorted2017 <-bitcoin_price_sorted[bitcoin_price_sorted$Year == 2017,]

resultats <- data.frame(Val2015= bitcoin_price_sorted2015$Close, Val2016=bitcoin_price_sorted2016$Close, Val2017=bitcoin_price_sorted2017$Close, Moi=bitcoin_price_sorted2015$Month ,Jour=bitcoin_price_sorted2015$DateFormat)
```

```{r plot_evolution_cours_btc_uniqueLine, echo=TRUE, message=FALSE, warning=FALSE}
ggplot(bitcoin_price_sorted, aes(x=as.Date(DateFormat), y=Open, color=Year, group=Year)) +
  ggtitle("Évolution du cours du Bitcoin (courbe unique)")+
  ylab("Valeurs (en $)")+
  scale_x_date(name="Months", labels = date_format("%b"), breaks = "3 month")+
  geom_line(aes(colour=Year), size=1)
```


```{r plot_evolution_cours_btc, echo=TRUE, message=FALSE, warning=FALSE}

prediction2 <- gather(
  data = resultats,
  key = TYPE,
  value = VAL,
  Val2015,Val2016, Val2017
)

ggplot(
  prediction2,
  aes(x = as.Date(Jour), y = VAL, color = TYPE),)+
  ggtitle("Évolution du cours du Bitcoin de 2015 à 2017")+
  ylab("Values")+
  scale_x_date(name="Months", labels = date_format("%b"), breaks = "1 month")+
  geom_line()
```


### Variations du cours du Bitcoin en 2016 et 2017
```{r variations_btc, message=FALSE, warning=FALSE, include=FALSE}
variationBtc_sorted_2016 <- variationBtc_sorted[variationBtc_sorted$Year == 2016,]
variationBtc_sorted_2016 <- variationBtc_sorted_2016[-60,]

variationBtc_sorted_2017 <- variationBtc_sorted[variationBtc_sorted$Year == 2017,]
```


```{r plot_variations_btc, echo=TRUE, message=FALSE, warning=FALSE}
## Création d'un nouveau data frame
## Plus exploitable
df <- data.frame(Val2016 = variationBtc_sorted_2016$Variation, 
                 Val2017 = variationBtc_sorted_2017$Variation, 
                 Month=variationBtc_sorted_2016$Month,
                 Date=variationBtc_sorted_2016$Date)

datas <- gather(
  data = df,
  key = TYPE,
  value = VAL,
  Val2016, Val2017
)

## Variations du cours du bitcoin en 2016 & 2017
## En %

ggplot(
  datas,
  aes(x = as.Date(Date), y = VAL, color = TYPE),)+
  ggtitle("Variations du cours du Bitcoin en 2016 & 2017")+
  ylab("Valeurs")+
  scale_x_date(name="Months", labels = date_format("%b"), breaks = "1 month")+
  geom_line()
```

### Moyennes et variances
```{r average_var_2017, echo=TRUE, message=FALSE, warning=FALSE}
##2017
bitcoin_price_sorted_2017 <- bitcoin_price_sorted[bitcoin_price_sorted$Year == 2017,]

##moyenne de 2017
moyBtcMin2017 <- mean(bitcoin_price_sorted_2017$Low)
moyBtcMax2017 <- mean(bitcoin_price_sorted_2017$High)
moyBtcVo2017l <-mean(bitcoin_price_sorted_2017$Volume)

##variance de 2017
varBtcMin2017 <- var(bitcoin_price_sorted_2017$Low)
varBtcMax2017 <- var(bitcoin_price_sorted_2017$High)
varBtcVol2017 <- var(bitcoin_price_sorted_2017$Volume)

##ecrat type de 2017
ecartBtcMin2017 <- sqrt(varBtcMin2017)
ecartBtcMax2017 <- sqrt(varBtcMax2017)
ecartBtcVol2017 <- sqrt(varBtcVol2017)

tabMoyLow2017<-0
tabMoyHigh2017<-0
tabMoyVol2017<-0
tabVarLow2017<-0
tabVarHigh2017<-0
tabVarVol2017<-0
tabEcartLow2017<-0
tabEcartHigh2017<-0
tabEcartVol2017<-0

##boucle permettant de remplir les tableaux de mois
for(i in 1:12){
  ##moyenne pour chaque mois
  tabMoyLow2017[i]<- mean(bitcoin_price_sorted_2017[bitcoin_price_sorted_2017$Month == i,]$Low)
  tabMoyHigh2017[i]<- mean(bitcoin_price_sorted_2017[bitcoin_price_sorted_2017$Month == i,]$High)
  tabMoyVol2017[i]<- mean(bitcoin_price_sorted_2017[bitcoin_price_sorted_2017$Month == i,]$Volume)
  
  ##variance pour chaque mois
  tabVarLow2017[i]<- var(bitcoin_price_sorted_2017[bitcoin_price_sorted_2017$Month == i,]$Low)
  tabVarHigh2017[i]<- var(bitcoin_price_sorted_2017[bitcoin_price_sorted_2017$Month == i,]$High)
  tabVarVol2017[i]<- var(bitcoin_price_sorted_2017[bitcoin_price_sorted_2017$Month == i,]$Volume)
  
  ##ecart type pour chaque mois
  tabEcartLow2017[i] <- sqrt(tabVarLow2017[i])
  tabEcartHigh2017[i] <- sqrt(tabVarHigh2017[i])
  tabEcartVol2017[i] <- sqrt(tabVarVol2017[i])
}

library(knitr)
kable(tabMoyHigh2017, caption = "test")
```


### Cours de toutes les cryptos

```{r all_crypto, echo=FALSE, message=FALSE, warning=FALSE}
getData2016 <-function(tab){
  tab$Year <- as.factor(tab$Year)
  res <- subset(tab, tab$Year != 2015)
  return(res)
}

bitcoin_price_sorted_all <- getData2016(bitcoin_price_sorted)
dash_price_sorted_all <- getData2016(dash_price_sorted)
ethereum_price_sorted_all <- getData2016(ethereum_price_sorted)
litecoin_price_sorted_all <- getData2016(litecoin_price_sorted)
monero_price_sorted_all <- getData2016(monero_price_sorted)
nem_price_sorted_all <- getData2016(nem_price_sorted)
ripple_price_sorted_all <- getData2016(ripple_price_sorted)

resultats <- data.frame(bitcoin= bitcoin_price_sorted_all$Close, dash=dash_price_sorted_all$Close, etherum=ethereum_price_sorted_all$Close,litecoin= litecoin_price_sorted_all$Close, monero=monero_price_sorted_all$Close, nem=nem_price_sorted_all$Close,ripple=ripple_price_sorted_all$Close, Moi=bitcoin_price_sorted_all$Month ,Jour=bitcoin_price_sorted_all$DateFormat)

prediction2 <- gather(
  data = resultats,
  key = TYPE,
  value = VAL,
  bitcoin, dash, etherum, litecoin, monero, nem, ripple
)

ggplot(
  prediction2,
  aes(x = as.Date(Jour), y = VAL, color = TYPE),
)+scale_x_date(name="Years", labels = date_format("%Y"), breaks = "1 year")+
geom_line()
```


### Part de marché par crypto-monnaies

```{r part_crypto_market, echo=FALSE, message=FALSE, warning=FALSE}
getLastMarketCap<-function(tab){
  tab$Year <- as.factor(tab$Year)
  col<-tab$Market.Cap
  val<-tail(col,1)
  val <- str_replace_all(val, ",", "")
  res<-as.numeric(val)
  
  return(res)
}

bitcoin_marketcap <- getLastMarketCap(bitcoin_price_sorted)
dash_marketcap <- getLastMarketCap(dash_price_sorted)
ethereum_marketcap <- getLastMarketCap(ethereum_price_sorted)
litecoin_marketcap <- getLastMarketCap(litecoin_price_sorted)
monero_marketcap <- getLastMarketCap(monero_price_sorted)
nem_marketcap <- getLastMarketCap(nem_price_sorted)
ripple_marketcap <- getLastMarketCap(ripple_price_sorted)

tab = c(bitcoin_marketcap,dash_marketcap,ethereum_marketcap,litecoin_marketcap,monero_marketcap,nem_marketcap,ripple_marketcap)

pie(tab,main="Part des crypto-monnaies (en%)",col = c("#FF0101","#4401FF","#01BBFF","#01FF4D","#F7FF01","#EE01FF","#FF9101"),labels = c("bitcoin","dash","ethereum","litecoin","","","ripple"),cex=1.5)


# Calculer pourcentages correspondant à chaque valeurs
total = sum(tab)
pourcentages = tab/total*100 ; cat("Les valeurs en % sont de :",pourcentages,"\n")
# Fonction à coller dans R - cette fonction text_pie permet d'ajouter des étiquettes au centre des quartiers
text_pie = function(vector,labels=c(),cex=1) {
  vector = vector/sum(vector)*2*pi
  temp = c()
  j = 0
  l = 0
  for (i in 1:length(vector)) {
    k = vector[i]/2        
    j =  j+l+k
    l = k
    text(cos(j)/2,sin(j)/2,labels[i],cex=cex)
  }
  vector = temp
}
pourcentage_affichage <- round(pourcentages,2)
# Ajouter les étiquettes
text_pie(pourcentages,c(pourcentage_affichage[1],pourcentage_affichage[2],pourcentage_affichage[3],pourcentage_affichage[4], "", "" ,pourcentage_affichage[6]),cex=1.1) # Ces valeurs en % sont à remplacer manuellement

legend(x="bottomright", legend=c("bitcoin","dash","ethereum","litecoin","monero","nem","ripple"), cex=1.2,fill=c("#FF0101","#4401FF","#01BBFF","#01FF4D","#F7FF01","#EE01FF","#FF9101"))
```


### Tests de corrélations

FONCTION CORRELATION TABLE
```{r calcul_matrice_corr, echo=TRUE, message=FALSE, warning=FALSE}

#calcule de la matrice de corrélation
correlationTable <- function(graphs) {
  #matrice de corrélation
  cross <- matrix(nrow = length(graphs), ncol = length(graphs))
  for(graph1Id in 1:length(graphs)){
    graph1 <- graphs[[graph1Id]]
    print(graph1Id)
    for(graph2Id in 1:length(graphs)) {
      graph2 <- graphs[[graph2Id]]
      if(graph1Id == graph2Id){
        break;
      } else {
        correlation <- ccf(graph1, graph2, lag.max = 0)
        cross[graph1Id, graph2Id] <- correlation$acf[1]
      }
    }
  }
  cross
}
```


```{r format_corr, message=FALSE, warning=FALSE, include=FALSE}
#graphs de corrélation des open (bitcoin par rapport aux autres crypto)
corrO <- correlationTable(graphsO)
#renommage des colnames et rownames
colnames(corrO) <- c("bitcoin_cash", "bitcoin", "bitconnect", "dash", "ethereum_classic", "ethereum", "iota",
                    "litecoin", "nem", "monero", "numeraire", "omisego", "neo", "ripple", "stratis", "qtum", "waves")
rownames(corrO) <- c("bitcoin_cash", "bitcoin", "bitconnect", "dash", "ethereum_classic", "ethereum", "iota",
                    "litecoin", "nem", "monero", "numeraire", "omisego", "neo", "ripple", "stratis", "qtum", "waves")

#graphs de corrélation des close (bitcoin par rapport aux autres crypto)
corrC <- correlationTable(graphsC)
colnames(corrC) <- c("bitcoin_cash", "bitcoin", "bitconnect", "dash", "ethereum_classic", "ethereum", "iota",
                    "litecoin", "nem", "monero", "numeraire", "omisego", "neo", "ripple", "stratis", "qtum", "waves")
rownames(corrC) <- c("bitcoin_cash", "bitcoin", "bitconnect", "dash", "ethereum_classic", "ethereum", "iota",
                    "litecoin", "nem", "monero", "numeraire", "omisego", "neo", "ripple", "stratis", "qtum", "waves")

#graphs de corrélation des market cap (bitcoin par rapport aux autres crypto)
corrM <- correlationTable(graphsM)
colnames(corrM) <- c("bitcoin_cash", "bitcoin", "bitconnect", "dash", "ethereum_classic", "ethereum", "iota",
                    "litecoin", "nem", "monero", "numeraire", "omisego", "neo", "ripple", "stratis", "qtum", "waves")
rownames(corrM) <- c("bitcoin_cash", "bitcoin", "bitconnect", "dash", "ethereum_classic", "ethereum", "iota",
                    "litecoin", "nem", "monero", "numeraire", "omisego", "neo", "ripple", "stratis", "qtum", "waves")
```

CORRELOGRAMMES
```{r plot_corr, echo=TRUE, message=FALSE, warning=FALSE}
#Corrélogramme : visualisation de la matrice de corrélation des Open
corrplot(corrO, title="Matrice de corrélation des valeurs Open", mar=c(0,0,1,0), type="lower")

#Corrélogramme : visualisation de la matrice de corrélation des Close
corrplot(corrC, title="Matrice de corrélation des valeurs Close", mar=c(0,0,1,0), type="lower")

#Corrélogramme : visualisation de la matrice de corrélation des Market.Cap
corrplot(corrM, title="Matrice de corrélation des valeurs Market.Cap", mar=c(0,0,1,0), type="lower")
```


